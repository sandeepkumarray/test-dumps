Step 5: Create Authentication Controllers

csharp
// Controllers/AuthController.cs
using Microsoft.AspNetCore.Mvc;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using YourApp.Services;
using YourApp.Models;

namespace YourApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthController : ControllerBase
    {
        private readonly ITenantSSOService _ssoService;
        private readonly IConfiguration _configuration;
        private readonly ILogger<AuthController> _logger;

        public AuthController(
            ITenantSSOService ssoService, 
            IConfiguration configuration,
            ILogger<AuthController> logger)
        {
            _ssoService = ssoService;
            _configuration = configuration;
            _logger = logger;
        }

        [HttpGet("tenant-config/{tenantId}")]
        public async Task<IActionResult> GetTenantConfig(string tenantId)
        {
            try
            {
                var config = await _ssoService.GetTenantConfigurationAsync(tenantId);
                if (config == null)
                {
                    return NotFound(new { message = "Tenant configuration not found" });
                }

                // Return only necessary info (never expose client secret)
                return Ok(new
                {
                    tenantId = config.TenantId,
                    tenantName = config.TenantName,
                    ssoEnabled = config.SSOEnabled,
                    mfaEnabled = config.MFAEnabled,
                    allowBothSSOAndMFA = config.AllowBothSSOAndMFA,
                    authority = config.Authority,
                    clientId = config.ClientId,
                    redirectUri = config.RedirectUri,
                    postLogoutRedirectUri = config.PostLogoutRedirectUri,
                    scope = config.Scope,
                    responseType = config.ResponseType
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving tenant configuration");
                return StatusCode(500, new { message = "Internal server error" });
            }
        }

        [HttpPost("sso-callback")]
        public async Task<IActionResult> SSOCallback([FromBody] SSOCallbackRequest request)
        {
            try
            {
                var config = await _ssoService.GetTenantConfigurationAsync(request.TenantId);
                if (config == null || !config.SSOEnabled)
                {
                    return BadRequest(new { message = "SSO not enabled for this tenant" });
                }

                // Validate the ID token (implement based on your IdP)
                var principal = ValidateIdToken(request.IdToken, config);
                if (principal == null)
                {
                    await _ssoService.LogSSOAttemptAsync(
                        request.TenantId, 
                        request.Email, 
                        "Failed", 
                        GetClientIpAddress());
                    return Unauthorized(new { message = "Invalid token" });
                }

                // Extract user info from claims
                var email = principal.FindFirst(ClaimTypes.Email)?.Value;
                var name = principal.FindFirst(ClaimTypes.Name)?.Value;

                // Generate your application's JWT token
                var token = GenerateJwtToken(request.TenantId, email, name);

                await _ssoService.LogSSOAttemptAsync(
                    request.TenantId, 
                    email, 
                    "Success", 
                    GetClientIpAddress());

                return Ok(new
                {
                    token,
                    user = new
                    {
                        email,
                        name,
                        tenantId = request.TenantId
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "SSO callback error");
                return StatusCode(500, new { message = "Authentication failed" });
            }
        }

        [HttpPost("mfa/setup")]
        public async Task<IActionResult> SetupMFA([FromBody] MFASetupRequest request)
        {
            // Implement TOTP MFA setup
            var secret = GenerateTOTPSecret();
            var qrCodeUrl = GenerateQRCodeUrl(request.Email, secret);

            return Ok(new
            {
                secret,
                qrCodeUrl
            });
        }

        [HttpPost("mfa/verify")]
        public async Task<IActionResult> VerifyMFA([FromBody] MFAVerifyRequest request)
        {
            // Implement TOTP verification
            var isValid = VerifyTOTPCode(request.Secret, request.Code);
            
            if (isValid)
            {
                var token = GenerateJwtToken(request.TenantId, request.Email, request.Name);
                return Ok(new { token });
            }

            return Unauthorized(new { message = "Invalid MFA code" });
        }

        private ClaimsPrincipal ValidateIdToken(string idToken, TenantSSOConfiguration config)
        {
            try
            {
                var tokenHandler = new JwtSecurityTokenHandler();
                var validationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidIssuer = config.Authority,
                    ValidateAudience = true,
                    ValidAudience = config.ClientId,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    // Configure based on your IdP's signing keys
                    IssuerSigningKeyResolver = (token, securityToken, kid, parameters) =>
                    {
                        // Implement key resolution from IdP's JWKS endpoint
                        return GetSigningKeys(config.Authority);
                    }
                };

                var principal = tokenHandler.ValidateToken(idToken, validationParameters, out _);
                return principal;
            }
            catch
            {
                return null;
            }
        }

        private string GenerateJwtToken(string tenantId, string email, string name)
        {
            var securityKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));
            var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

            var claims = new[]
            {
                new Claim(ClaimTypes.Email, email),
                new Claim(ClaimTypes.Name, name),
                new Claim("tenantId", tenantId),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
            };

            var token = new JwtSecurityToken(
                issuer: _configuration["Jwt:Issuer"],
                audience: _configuration["Jwt:Audience"],
                claims: claims,
                expires: DateTime.Now.AddHours(8),
                signingCredentials: credentials
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }

        private IEnumerable<SecurityKey> GetSigningKeys(string authority)
        {
            // Implement retrieval of signing keys from IdP's JWKS endpoint
            // This is a placeholder - implement based on your IdP
            throw new NotImplementedException();
        }

        private string GenerateTOTPSecret()
        {
            var random = new byte[20];
            using (var rng = System.Security.Cryptography.RandomNumberGenerator.Create())
            {
                rng.GetBytes(random);
            }
            return Convert.ToBase64String(random);
        }

        private string GenerateQRCodeUrl(string email, string secret)
        {
            var appName = _configuration["App:Name"] ?? "YourApp";
            return $"otpauth://totp/{appName}:{email}?secret={secret}&issuer={appName}";
        }

        private bool VerifyTOTPCode(string secret, string code)
        {
            // Implement TOTP verification using a library like OtpNet
            // This is a placeholder
            return true;
        }

        private string GetClientIpAddress()
        {
            return HttpContext.Connection.RemoteIpAddress?.ToString() ?? "Unknown";
        }
    }

    public class SSOCallbackRequest
    {
        public string TenantId { get; set; }
        public string IdToken { get; set; }
        public string Email { get; set; }
    }

    public class MFASetupRequest
    {
        public string Email { get; set; }
        public string TenantId { get; set; }
    }

    public class MFAVerifyRequest
    {
        public string TenantId { get; set; }
        public string Email { get; set; }
        public string Name { get; set; }
        public string Secret { get; set; }
        public string Code { get; set; }
    }
}

// Controllers/TenantController.cs
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using YourApp.Models;
using YourApp.Services;

namespace YourApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize] // Require admin role in production
    public class TenantController : ControllerBase
    {
        private readonly ITenantSSOService _ssoService;

        public TenantController(ITenantSSOService ssoService)
        {
            _ssoService = ssoService;
        }

        [HttpPost("configure-sso")]
        public async Task<IActionResult> ConfigureSSO([FromBody] TenantSSOConfiguration config)
        {
            try
            {
                var result = await _ssoService.CreateOrUpdateConfigurationAsync(config);
                return Ok(new { message = "SSO configuration saved successfully", tenantId = result.TenantId });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "Failed to save configuration", error = ex.Message });
            }
        }

        [HttpGet("sso-config/{tenantId}")]
        public async Task<IActionResult> GetSSOConfig(string tenantId)
        {
            var config = await _ssoService.GetTenantConfigurationAsync(tenantId);
            if (config == null)
            {
                return NotFound();
            }
            return Ok(config);
        }
    }
}

Frontend Implementation (Angular 18)
Step 6: Install Required Packages

bash
npm install angular-auth-oidc-client@^18.0.0
npm install @angular/common@^18.0.0
npm install @angular/core@^18.0.0

Step 7: Create Auth Service

typescript
// src/app/services/auth.service.ts
import { Injectable, inject, signal } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { OidcSecurityService, LoginResponse } from 'angular-auth-oidc-client';
import { Observable, BehaviorSubject, from, of } from 'rxjs';
import { map, switchMap, catchError, tap } from 'rxjs/operators';
import { Router } from '@angular/router';

export interface TenantConfig {
  tenantId: string;
  tenantName: string;
  ssoEnabled: boolean;
  mfaEnabled: boolean;
  allowBothSSOAndMFA: boolean;
  authority: string;
  clientId: string;
  redirectUri: string;
  postLogoutRedirectUri: string;
  scope: string;
  responseType: string;
}

export interface User {
  email: string;
  name: string;
  tenantId: string;
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private http = inject(HttpClient);
  private router = inject(Router);
  private oidcSecurityService = inject(OidcSecurityService);
  
  private apiUrl = 'https://your-api-url.com/api';
  
  // Signals for reactive state management (Angular 18 feature)
  isAuthenticated = signal<boolean>(false);
  currentUser = signal<User | null>(null);
  currentTenant = signal<TenantConfig | null>(null);
  
  private tokenSubject = new BehaviorSubject<string | null>(
    localStorage.getItem('access_token')
  );
  public token$ = this.tokenSubject.asObservable();

  constructor() {
    this.initializeAuth();
  }

  private initializeAuth(): void {
    const token = localStorage.getItem('access_token');
    const user = localStorage.getItem('current_user');
    
    if (token && user) {
      this.isAuthenticated.set(true);
      this.currentUser.set(JSON.parse(user));
      this.tokenSubject.next(token);
    }
  }

  getTenantConfiguration(tenantId: string): Observable<TenantConfig> {
    return this.http.get<TenantConfig>(
      `${this.apiUrl}/auth/tenant-config/${tenantId}`
    ).pipe(
      tap(config => this.currentTenant.set(config)),
      catchError(error => {
        console.error('Error fetching tenant config:', error);
        throw error;
      })
    );
  }

  initializeSSO(tenantId: string): Observable<void> {
    return this.getTenantConfiguration(tenantId).pipe(
      switchMap(config => {
        if (!config.ssoEnabled) {
          throw new Error('SSO is not enabled for this tenant');
        }

        // Dynamically configure OIDC
        return from(this.configureOIDC(config));
      })
    );
  }

  private async configureOIDC(config: TenantConfig): Promise<void> {
    // Note: angular-auth-oidc-client v18 supports dynamic configuration
    const oidcConfig = {
      authority: config.authority,
      redirectUrl: config.redirectUri || window.location.origin,
      postLogoutRedirectUri: config.postLogoutRedirectUri || window.location.origin,
      clientId: config.clientId,
      scope: config.scope,
      responseType: config.responseType,
      silentRenew: true,
      useRefreshToken: true,
      renewTimeBeforeTokenExpiresInSeconds: 30
    };

    // Configure the OIDC service dynamically
    // This requires custom implementation or using multiple configs
    console.log('OIDC configured for tenant:', config.tenantId);
  }

  loginWithSSO(): void {
    this.oidcSecurityService.authorize();
  }

  handleSSOCallback(): Observable<boolean> {
    return this.oidcSecurityService.checkAuth().pipe(
      switchMap((loginResponse: LoginResponse) => {
        const { isAuthenticated, userData, accessToken, idToken } = loginResponse;
        
        if (isAuthenticated && idToken) {
          const tenantId = this.currentTenant()?.tenantId;
          
          // Send ID token to backend for validation and app token generation
          return this.http.post<{ token: string; user: User }>(
            `${this.apiUrl}/auth/sso-callback`,
            {
              tenantId,
              idToken,
              email: userData?.email
            }
          ).pipe(
            map(response => {
              this.setSession(response.token, response.user);
              return true;
            })
          );
        }
        return of(false);
      }),
      catchError(error => {
        console.error('SSO callback error:', error);
        return of(false);
      })
    );
  }

  loginWithPassword(email: string, password: string, tenantId: string): Observable<boolean> {
    return this.http.post<{ token: string; user: User }>(
      `${this.apiUrl}/auth/login`,
      { email, password, tenantId }
    ).pipe(
      map(response => {
        this.setSession(response.token, response.user);
        return true;
      }),
      catchError(error => {
        console.error('Login error:', error);
        return of(false);
      })
    );
  }

  setupMFA(email: string, tenantId: string): Observable<{ secret: string; qrCodeUrl: string }> {
    return this.http.post<{ secret: string; qrCodeUrl: string }>(
      `${this.apiUrl}/auth/mfa/setup`,
      { email, tenantId }
    );
  }

  verifyMFA(code: string, secret: string, email: string, tenantId: string): Observable<boolean> {
    return this.http.post<{ token: string }>(
      `${this.apiUrl}/auth/mfa/verify`,
      { code, secret, email, tenantId, name: email }
    ).pipe(
      map(response => {
        this.setSession(response.token, { email, name: email, tenantId });
        return true;
      }),
      catchError(() => of(false))
    );
  }

  private setSession(token: string, user: User): void {
    localStorage.setItem('access_token', token);
    localStorage.setItem('current_user', JSON.stringify(user));
    this.tokenSubject.next(token);
    this.isAuthenticated.set(true);
    this.currentUser.set(user);
  }

  logout(): void {
    localStorage.removeItem('access_token');
    localStorage.removeItem('current_user');
    this.tokenSubject.next(null);
    this.isAuthenticated.set(false);
    this.currentUser.set(null);
    this.currentTenant.set(null);
    
    if (this.currentTenant()?.ssoEnabled) {
      this.oidcSecurityService.logoff().subscribe();
    }
    
    this.router.navigate(['/login']);
  }

  getToken(): string | null {
    return this.tokenSubject.value;
  }

  isLoggedIn(): boolean {
    return this.isAuthenticated();
  }
}

Step 8: Create HTTP Interceptor

typescript
// src/app/interceptors/auth.interceptor.ts
import { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';
import { AuthService } from '../services/auth.service';

export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const token = authService.getToken();

  if (token) {
    const cloned = req.clone({
      headers: req.headers.set('Authorization', `Bearer ${token}`)
    });
    return next(cloned);
  }

  return next(req);
};

Step 9: Create Login Component

typescript
// src/app/components/login/login.component.ts
import { Component, OnInit, signal, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { AuthService, TenantConfig } from '../../services/auth.service';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.css']
})
export class LoginComponent implements OnInit {
  private fb = inject(FormBuilder);
  private authService = inject(AuthService);
  private router = inject(Router);

  loginForm: FormGroup;
  tenantConfig = signal<TenantConfig | null>(null);
  loading = signal<boolean>(false);
  error = signal<string | null>(null);
  showMFASetup = signal<boolean>(false);
  mfaSecret = signal<string>('');
  mfaQRCode = signal<string>('');
  showMFAVerify = signal<boolean>(false);

  ngOnInit(): void {
    this.loginForm = this.fb.group({
      tenantId: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      password: [''],
      mfaCode: ['']
    });
  }

  onTenantIdChange(): void {
    const tenantId = this.loginForm.get('tenantId')?.value;
    if (tenantId) {
      this.loading.set(true);
      this.authService.getTenantConfiguration(tenantId).subscribe({
        next: (config) => {
          this.tenantConfig.set(config);
          this.loading.set(false);
        },
        error: (err) => {
          this.error.set('Invalid tenant ID');
          this.loading.set(false);
        }
      });
    }
  }

  loginWithSSO(): void {
    const tenantId = this.loginForm.get('tenantId')?.value;
    
    this.loading.set(true);
    this.authService.initializeSSO(tenantId).subscribe({
      next: () => {
        this.authService.loginWithSSO();
      },
      error: (err) => {
        this.error.set('SSO initialization failed');
        this.loading.set(false);
      }
    });
  }

  loginWithPassword(): void {
    if (this.loginForm.invalid) {
      return;
    }

    const { email, password, tenantId } = this.loginForm.value;
    
    this.loading.set(true);
    this.authService.loginWithPassword(email, password, tenantId).subscribe({
      next: (success) => {
        if (success) {
          const config = this.tenantConfig();
          if (config?.mfaEnabled) {
            this.setupMFA();
          } else {
            this.router.navigate(['/dashboard']);
          }
        } else {
          this.error.set('Invalid credentials');
        }
        this.loading.set(false);
      },
      error: () => {
        this.error.set('Login failed');
        this.loading.set(false);
      }
    });
  }

  setupMFA(): void {
    const { email, tenantId } = this.loginForm.value;
    
    this.authService.setupMFA(email, tenantId).subscribe({
      next: (response) => {
        this.mfaSecret.set(response.secret);
        this.mfaQRCode.set(response.qrCodeUrl);
        this.showMFASetup.set(true);
      },
      error: () => {
        this.error.set('MFA setup failed');
      }
    });
  }

  proceedToMFAVerification(): void {
    this.showMFASetup.set(false);
    this.showMFAVerify.set(true);
  }

  verifyMFA(): void {
    const { email, tenantId, mfaCode } = this.loginForm.value;
    const secret = this.mfaSecret();

    this.authService.verifyMFA(mfaCode, secret, email, tenantId).subscribe({
      next: (success) => {
        if (success) {
          this.router.navigate(['/dashboard']);
        } else {
          this.error.set('Invalid MFA code');
        }
      }
    });
  }
}

xml
<!-- src/app/components/login/login.component.html -->
<div class="login-container">
  <div class="login-card">
    <h2>Login</h2>
    
    @if (error()) {
      <div class="alert alert-danger">{{ error() }}</div>
    }

    @if (!showMFASetup() && !showMFAVerify()) {
      <form [formGroup]="loginForm">
        <div class="form-group">
          <label for="tenantId">Tenant ID</label>
          <input 
            type="text" 
            id="tenantId"
            formControlName="tenantId"
            (blur)="onTenantIdChange()"
            class="form-control"
            placeholder="Enter your tenant ID"
          />
        </div>

        @if (tenantConfig()) {
          <div class="tenant-info">
            <p><strong>{{ tenantConfig()?.tenantName }}</strong></p>
            
            @if (tenantConfig()?.ssoEnabled) {
              <button 
                type="button"
                (click)="loginWithSSO()"
                [disabled]="loading()"
                class="btn btn-primary btn-block"
              >
                @if (loading()) {
                  <span class="spinner"></span>
                }
                Login with SSO
              </button>
            }

            @if (tenantConfig()?.allowBothSSOAndMFA || !tenantConfig()?.ssoEnabled) {
              <div class="divider">OR</div>

              <div class="form-group">
                <label for="email">Email</label>
                <input 
                  type="email"
                  id="email"
                  formControlName="email"
                  class="form-control"
                  placeholder="Enter your email"
                />
              </div>

              <div class="form-group">
                <label for="password">Password</label>
                <input 
                  type="password"
                  id="password"
                  formControlName="password"
                  class="form-control"
                  placeholder="Enter your password"
                />
              </div>

              <button 
                type="button"
                (click)="loginWithPassword()"
                [disabled]="loading() || loginForm.invalid"
                class="btn btn-secondary btn-block"
              >
                @if (loading()) {
                  <span class="spinner"></span>
                }
                Login with Password
              </button>
            }
          </div>
        }
      </form>
    }

    @if (showMFASetup()) {
      <div class="mfa-setup">
        <h3>Setup Multi-Factor Authentication</h3>
        <p>Scan this QR code with your authenticator app:</p>
        <img [src]="'https://api.qrserver.com/v1/create-qr-code/?data=' + encodeURIComponent(mfaQRCode()) + '&size=200x200'" alt="MFA QR Code" />
        <p class="mfa-secret"><strong>Secret:</strong> {{ mfaSecret() }}</p>
        <button 
          type="button"
          (click)="proceedToMFAVerification()"
          class="btn btn-primary"
        >
          Continue to Verification
        </button>
      </div>
    }

    @if (showMFAVerify()) {
      <div class="mfa-verify">
        <h3>Enter Verification Code</h3>
        <form [formGroup]="loginForm">
          <div class="form-group">
            <label for="mfaCode">6-Digit Code</label>
            <input 
              type="text"
              id="mfaCode"
              formControlName="mfaCode"
              class="form-control"
              placeholder="000000"
              maxlength="6"
            />
          </div>
          <button 
            type="button"
            (click)="verifyMFA()"
            [disabled]="loading()"
            class="btn btn-primary btn-block"
          >
            Verify
          </button>
        </form>
      </div>
    }
  </div>
</div>

Step 10: Configure App Module

typescript
// src/app/app.config.ts
import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { authInterceptor } from './interceptors/auth.interceptor';
import { AuthModule } from 'angular-auth-oidc-client';

import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    provideHttpClient(
      withInterceptors([authInterceptor])
    )
  ]
};

// src/app/app.component.ts
import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { AuthModule } from 'angular-auth-oidc-client';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, AuthModule],
  template: '<router-outlet></router-outlet>'
})
export class AppComponent {}

Configuration Files
Step 11: Backend Configuration

json
// appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=your-server;Database=your-db;User Id=your-user;Password=your-password;"
  },
  "Jwt": {
    "Key": "your-super-secret-key-min-32-chars",
    "Issuer": "https://your-api-url.com",
    "Audience": "https://your-angular-app.com"
  },
  "Encryption": {
    "Key": "your-encryption-key-32-chars"
  },
  "App": {
    "Name": "YourAppName"
  },
  "Cors": {
    "AllowedOrigins": ["http://localhost:4200", "https://your-angular-app.com"]
  }
}

Implementation Checklist
Things to Follow When Adding to Existing App:

    Database Migration:​

        Back up your existing database before running migrations

        Test migrations in a development environment first

        Consider adding indexes for tenant lookups

    Security Considerations:

        Always encrypt client secrets in the database​

        Implement rate limiting on authentication endpoints

        Use HTTPS in production

        Validate redirect URIs to prevent open redirect attacks

        Implement CORS properly

    Testing Strategy:

        Test with at least 2 different IdPs (e.g., Microsoft Entra ID, Okta)

        Test both SSO and MFA flows separately

        Test the combination of SSO + MFA if applicable

        Test token expiration and refresh scenarios

    Caching Strategy:​

        Cache tenant configurations to reduce database queries

        Invalidate cache when configurations are updated

        Set appropriate cache expiration times

    Logging and Monitoring:

        Log all authentication attempts

        Monitor failed login attempts for security

        Track SSO errors for troubleshooting

Things to Expect When Adding Client Details:

    Required Information from Clients:

        Identity Provider (IdP) type (Microsoft Entra ID, Okta, Google, etc.)

        Authority/Issuer URL

        Client ID (from their IdP)

        Client Secret (from their IdP)

        Redirect URIs (your application URLs)

        Metadata URL (optional, for automatic configuration)

        Scopes required

    Client-Side Setup Requirements:

        Clients need to register your application in their IdP

        They must whitelist your redirect URIs

        They may need to configure user provisioning

        They need to provide you with credentials securely

    Common Challenges:

        Different IdPs may have slightly different implementations

        Token claim names may vary between providers

        Some clients may have network restrictions

        Certificate and key rotation policies

    Support Documentation to Provide:

        Step-by-step guide for each major IdP

        Your application's redirect URIs

        Required scopes and permissions

        Troubleshooting guide

Required NuGet Packages (.NET)

xml
<ItemGroup>
  <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />
  <PackageReference Include="Microsoft.AspNetCore.Authentication.OpenIdConnect" Version="8.0.0" />
  <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.0" />
  <PackageReference Include="Microsoft.IdentityModel.Tokens" Version="7.0.0" />
  <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="7.0.0" />
  <PackageReference Include="Otp.NET" Version="1.3.0" /> <!-- For TOTP MFA -->
</ItemGroup>

This complete implementation provides a production-ready multi-tenant SSO and MFA solution for your Angular 18 and .NET application. The architecture dynamically loads tenant-specific configurations from SQL Server and supports multiple authentication methods per client.
