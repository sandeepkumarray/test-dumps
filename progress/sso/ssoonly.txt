Solution Architecture

This solution implements a multi-tenant SSO system where each tenant can configure their own OAuth/SSO provider details, supporting multiple authentication schemes simultaneously.​
Database Schema (PostgreSQL)

sql
-- SSO Provider Configurations Table
CREATE TABLE sso_providers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    provider_name VARCHAR(100) NOT NULL,
    provider_type VARCHAR(50) NOT NULL, -- e.g., 'OAuth2', 'SAML', 'OpenIdConnect'
    client_id VARCHAR(255) NOT NULL,
    client_secret TEXT NOT NULL, -- Encrypted
    authority VARCHAR(500), -- Token endpoint/IDP URL
    grant_type VARCHAR(50) DEFAULT 'authorization_code',
    scope TEXT, -- Space-separated scopes
    redirect_uri VARCHAR(500),
    metadata_url VARCHAR(500),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(100),
    
    CONSTRAINT unique_provider_name UNIQUE(provider_name)
);

-- Additional SSO Configuration (Key-Value pairs for flexibility)
CREATE TABLE sso_provider_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sso_provider_id UUID NOT NULL REFERENCES sso_providers(id) ON DELETE CASCADE,
    setting_key VARCHAR(100) NOT NULL,
    setting_value TEXT,
    is_encrypted BOOLEAN DEFAULT false,
    
    CONSTRAINT unique_provider_setting UNIQUE(sso_provider_id, setting_key)
);

-- User SSO Mappings (Track which users use which SSO)
CREATE TABLE user_sso_mappings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    sso_provider_id UUID NOT NULL REFERENCES sso_providers(id) ON DELETE CASCADE,
    external_user_id VARCHAR(255) NOT NULL, -- User ID from SSO provider
    email VARCHAR(255),
    last_login TIMESTAMP,
    
    CONSTRAINT unique_user_provider UNIQUE(user_id, sso_provider_id)
);

-- Audit Log for SSO Activities
CREATE TABLE sso_audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sso_provider_id UUID REFERENCES sso_providers(id),
    user_id UUID,
    action VARCHAR(50), -- 'login_success', 'login_failed', 'config_updated'
    ip_address VARCHAR(50),
    user_agent TEXT,
    details JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_sso_providers_active ON sso_providers(is_active);
CREATE INDEX idx_user_sso_mappings_user ON user_sso_mappings(user_id);
CREATE INDEX idx_sso_audit_logs_created ON sso_audit_logs(created_at DESC);

ASP.NET Core API Implementation
1. Project Structure

text
SSOManagement.API/
├── Controllers/
│   ├── SSOProvidersController.cs
│   └── AuthenticationController.cs
├── Models/
│   ├── Entities/
│   │   ├── SSOProvider.cs
│   │   ├── SSOProviderSetting.cs
│   │   └── UserSSOMapping.cs
│   └── DTOs/
│       ├── SSOProviderDto.cs
│       └── SSOConfigurationDto.cs
├── Data/
│   └── ApplicationDbContext.cs
├── Services/
│   ├── ISSOProviderService.cs
│   ├── SSOProviderService.cs
│   ├── IEncryptionService.cs
│   └── EncryptionService.cs
├── Repositories/
│   ├── ISSOProviderRepository.cs
│   └── SSOProviderRepository.cs
└── Configuration/
    └── DynamicAuthenticationHandler.cs

2. Entity Models

csharp
// Models/Entities/SSOProvider.cs
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace SSOManagement.API.Models.Entities
{
    [Table("sso_providers")]
    public class SSOProvider
    {
        [Key]
        [Column("id")]
        public Guid Id { get; set; } = Guid.NewGuid();

        [Required]
        [Column("provider_name")]
        [MaxLength(100)]
        public string ProviderName { get; set; }

        [Required]
        [Column("provider_type")]
        [MaxLength(50)]
        public string ProviderType { get; set; } // OAuth2, SAML, OpenIdConnect

        [Required]
        [Column("client_id")]
        [MaxLength(255)]
        public string ClientId { get; set; }

        [Required]
        [Column("client_secret")]
        public string ClientSecret { get; set; } // Encrypted

        [Column("authority")]
        [MaxLength(500)]
        public string Authority { get; set; }

        [Column("grant_type")]
        [MaxLength(50)]
        public string GrantType { get; set; } = "authorization_code";

        [Column("scope")]
        public string Scope { get; set; }

        [Column("redirect_uri")]
        [MaxLength(500)]
        public string RedirectUri { get; set; }

        [Column("metadata_url")]
        [MaxLength(500)]
        public string MetadataUrl { get; set; }

        [Column("is_active")]
        public bool IsActive { get; set; } = true;

        [Column("created_at")]
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        [Column("updated_at")]
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

        [Column("created_by")]
        [MaxLength(100)]
        public string CreatedBy { get; set; }

        public ICollection<SSOProviderSetting> Settings { get; set; }
        public ICollection<UserSSOMapping> UserMappings { get; set; }
    }

    [Table("sso_provider_settings")]
    public class SSOProviderSetting
    {
        [Key]
        [Column("id")]
        public Guid Id { get; set; } = Guid.NewGuid();

        [Required]
        [Column("sso_provider_id")]
        public Guid SSOProviderId { get; set; }

        [Required]
        [Column("setting_key")]
        [MaxLength(100)]
        public string SettingKey { get; set; }

        [Column("setting_value")]
        public string SettingValue { get; set; }

        [Column("is_encrypted")]
        public bool IsEncrypted { get; set; } = false;

        [ForeignKey("SSOProviderId")]
        public SSOProvider SSOProvider { get; set; }
    }

    [Table("user_sso_mappings")]
    public class UserSSOMapping
    {
        [Key]
        [Column("id")]
        public Guid Id { get; set; } = Guid.NewGuid();

        [Required]
        [Column("user_id")]
        public Guid UserId { get; set; }

        [Required]
        [Column("sso_provider_id")]
        public Guid SSOProviderId { get; set; }

        [Required]
        [Column("external_user_id")]
        [MaxLength(255)]
        public string ExternalUserId { get; set; }

        [Column("email")]
        [MaxLength(255)]
        public string Email { get; set; }

        [Column("last_login")]
        public DateTime? LastLogin { get; set; }

        [ForeignKey("SSOProviderId")]
        public SSOProvider SSOProvider { get; set; }
    }
}

3. DTOs

csharp
// Models/DTOs/SSOProviderDto.cs
namespace SSOManagement.API.Models.DTOs
{
    public class SSOProviderDto
    {
        public Guid? Id { get; set; }
        public string ProviderName { get; set; }
        public string ProviderType { get; set; }
        public string ClientId { get; set; }
        public string ClientSecret { get; set; } // Only for create/update
        public string Authority { get; set; }
        public string GrantType { get; set; }
        public string Scope { get; set; }
        public string RedirectUri { get; set; }
        public string MetadataUrl { get; set; }
        public bool IsActive { get; set; } = true;
        public Dictionary<string, string> AdditionalSettings { get; set; }
    }

    public class SSOProviderResponseDto
    {
        public Guid Id { get; set; }
        public string ProviderName { get; set; }
        public string ProviderType { get; set; }
        public string ClientId { get; set; }
        public string Authority { get; set; }
        public string GrantType { get; set; }
        public string Scope { get; set; }
        public string RedirectUri { get; set; }
        public bool IsActive { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }
        // Note: ClientSecret is never returned in responses
    }

    public class SSOLoginRequest
    {
        public string ProviderName { get; set; }
        public string ReturnUrl { get; set; }
    }

    public class SSOCallbackRequest
    {
        public string Code { get; set; }
        public string State { get; set; }
        public string ProviderName { get; set; }
    }
}

4. Database Context

csharp
// Data/ApplicationDbContext.cs
using Microsoft.EntityFrameworkCore;
using SSOManagement.API.Models.Entities;

namespace SSOManagement.API.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        public DbSet<SSOProvider> SSOProviders { get; set; }
        public DbSet<SSOProviderSetting> SSOProviderSettings { get; set; }
        public DbSet<UserSSOMapping> UserSSOMappings { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Configure unique constraints
            modelBuilder.Entity<SSOProvider>()
                .HasIndex(p => p.ProviderName)
                .IsUnique();

            modelBuilder.Entity<SSOProviderSetting>()
                .HasIndex(s => new { s.SSOProviderId, s.SettingKey })
                .IsUnique();

            modelBuilder.Entity<UserSSOMapping>()
                .HasIndex(m => new { m.UserId, m.SSOProviderId })
                .IsUnique();

            // Configure relationships
            modelBuilder.Entity<SSOProvider>()
                .HasMany(p => p.Settings)
                .WithOne(s => s.SSOProvider)
                .HasForeignKey(s => s.SSOProviderId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<SSOProvider>()
                .HasMany(p => p.UserMappings)
                .WithOne(m => m.SSOProvider)
                .HasForeignKey(m => m.SSOProviderId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
}

5. Encryption Service

csharp
// Services/IEncryptionService.cs
namespace SSOManagement.API.Services
{
    public interface IEncryptionService
    {
        string Encrypt(string plainText);
        string Decrypt(string cipherText);
    }
}

// Services/EncryptionService.cs
using System.Security.Cryptography;
using System.Text;

namespace SSOManagement.API.Services
{
    public class EncryptionService : IEncryptionService
    {
        private readonly byte[] _key;
        private readonly byte[] _iv;

        public EncryptionService(IConfiguration configuration)
        {
            // Store these securely in Azure Key Vault or AWS Secrets Manager
            var keyString = configuration["Encryption:Key"] ?? 
                throw new InvalidOperationException("Encryption key not configured");
            var ivString = configuration["Encryption:IV"] ?? 
                throw new InvalidOperationException("Encryption IV not configured");

            _key = Convert.FromBase64String(keyString);
            _iv = Convert.FromBase64String(ivString);
        }

        public string Encrypt(string plainText)
        {
            if (string.IsNullOrEmpty(plainText))
                return plainText;

            using var aes = Aes.Create();
            aes.Key = _key;
            aes.IV = _iv;

            var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

            using var msEncrypt = new MemoryStream();
            using var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
            using (var swEncrypt = new StreamWriter(csEncrypt))
            {
                swEncrypt.Write(plainText);
            }

            return Convert.ToBase64String(msEncrypt.ToArray());
        }

        public string Decrypt(string cipherText)
        {
            if (string.IsNullOrEmpty(cipherText))
                return cipherText;

            using var aes = Aes.Create();
            aes.Key = _key;
            aes.IV = _iv;

            var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

            using var msDecrypt = new MemoryStream(Convert.FromBase64String(cipherText));
            using var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);
            using var srDecrypt = new StreamReader(csDecrypt);

            return srDecrypt.ReadToEnd();
        }
    }
}

6. SSO Provider Service

csharp
// Services/ISSOProviderService.cs
using SSOManagement.API.Models.DTOs;
using SSOManagement.API.Models.Entities;

namespace SSOManagement.API.Services
{
    public interface ISSOProviderService
    {
        Task<SSOProviderResponseDto> CreateProviderAsync(SSOProviderDto dto);
        Task<SSOProviderResponseDto> UpdateProviderAsync(Guid id, SSOProviderDto dto);
        Task<SSOProviderResponseDto> GetProviderByIdAsync(Guid id);
        Task<SSOProviderResponseDto> GetProviderByNameAsync(string name);
        Task<IEnumerable<SSOProviderResponseDto>> GetAllProvidersAsync(bool activeOnly = true);
        Task<bool> DeleteProviderAsync(Guid id);
        Task<bool> ToggleProviderStatusAsync(Guid id);
    }
}

// Services/SSOProviderService.cs
using AutoMapper;
using Microsoft.EntityFrameworkCore;
using SSOManagement.API.Data;
using SSOManagement.API.Models.DTOs;
using SSOManagement.API.Models.Entities;

namespace SSOManagement.API.Services
{
    public class SSOProviderService : ISSOProviderService
    {
        private readonly ApplicationDbContext _context;
        private readonly IEncryptionService _encryptionService;
        private readonly IMapper _mapper;
        private readonly ILogger<SSOProviderService> _logger;

        public SSOProviderService(
            ApplicationDbContext context,
            IEncryptionService encryptionService,
            IMapper mapper,
            ILogger<SSOProviderService> logger)
        {
            _context = context;
            _encryptionService = encryptionService;
            _mapper = mapper;
            _logger = logger;
        }

        public async Task<SSOProviderResponseDto> CreateProviderAsync(SSOProviderDto dto)
        {
            var existingProvider = await _context.SSOProviders
                .FirstOrDefaultAsync(p => p.ProviderName == dto.ProviderName);

            if (existingProvider != null)
                throw new InvalidOperationException($"Provider '{dto.ProviderName}' already exists");

            var provider = new SSOProvider
            {
                ProviderName = dto.ProviderName,
                ProviderType = dto.ProviderType,
                ClientId = dto.ClientId,
                ClientSecret = _encryptionService.Encrypt(dto.ClientSecret),
                Authority = dto.Authority,
                GrantType = dto.GrantType,
                Scope = dto.Scope,
                RedirectUri = dto.RedirectUri,
                MetadataUrl = dto.MetadataUrl,
                IsActive = dto.IsActive,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            _context.SSOProviders.Add(provider);

            // Add additional settings if provided
            if (dto.AdditionalSettings != null && dto.AdditionalSettings.Any())
            {
                foreach (var setting in dto.AdditionalSettings)
                {
                    _context.SSOProviderSettings.Add(new SSOProviderSetting
                    {
                        SSOProviderId = provider.Id,
                        SettingKey = setting.Key,
                        SettingValue = setting.Value,
                        IsEncrypted = false
                    });
                }
            }

            await _context.SaveChangesAsync();
            _logger.LogInformation("Created SSO provider: {ProviderName}", provider.ProviderName);

            return _mapper.Map<SSOProviderResponseDto>(provider);
        }

        public async Task<SSOProviderResponseDto> UpdateProviderAsync(Guid id, SSOProviderDto dto)
        {
            var provider = await _context.SSOProviders
                .Include(p => p.Settings)
                .FirstOrDefaultAsync(p => p.Id == id);

            if (provider == null)
                throw new KeyNotFoundException($"Provider with ID {id} not found");

            provider.ProviderName = dto.ProviderName;
            provider.ProviderType = dto.ProviderType;
            provider.ClientId = dto.ClientId;
            
            if (!string.IsNullOrEmpty(dto.ClientSecret))
                provider.ClientSecret = _encryptionService.Encrypt(dto.ClientSecret);

            provider.Authority = dto.Authority;
            provider.GrantType = dto.GrantType;
            provider.Scope = dto.Scope;
            provider.RedirectUri = dto.RedirectUri;
            provider.MetadataUrl = dto.MetadataUrl;
            provider.IsActive = dto.IsActive;
            provider.UpdatedAt = DateTime.UtcNow;

            // Update additional settings
            if (dto.AdditionalSettings != null)
            {
                var existingSettings = provider.Settings.ToList();
                _context.SSOProviderSettings.RemoveRange(existingSettings);

                foreach (var setting in dto.AdditionalSettings)
                {
                    _context.SSOProviderSettings.Add(new SSOProviderSetting
                    {
                        SSOProviderId = provider.Id,
                        SettingKey = setting.Key,
                        SettingValue = setting.Value
                    });
                }
            }

            await _context.SaveChangesAsync();
            _logger.LogInformation("Updated SSO provider: {ProviderName}", provider.ProviderName);

            return _mapper.Map<SSOProviderResponseDto>(provider);
        }

        public async Task<SSOProviderResponseDto> GetProviderByIdAsync(Guid id)
        {
            var provider = await _context.SSOProviders
                .AsNoTracking()
                .FirstOrDefaultAsync(p => p.Id == id);

            if (provider == null)
                throw new KeyNotFoundException($"Provider with ID {id} not found");

            return _mapper.Map<SSOProviderResponseDto>(provider);
        }

        public async Task<SSOProviderResponseDto> GetProviderByNameAsync(string name)
        {
            var provider = await _context.SSOProviders
                .AsNoTracking()
                .FirstOrDefaultAsync(p => p.ProviderName == name);

            if (provider == null)
                throw new KeyNotFoundException($"Provider '{name}' not found");

            return _mapper.Map<SSOProviderResponseDto>(provider);
        }

        public async Task<IEnumerable<SSOProviderResponseDto>> GetAllProvidersAsync(bool activeOnly = true)
        {
            var query = _context.SSOProviders.AsNoTracking();

            if (activeOnly)
                query = query.Where(p => p.IsActive);

            var providers = await query.OrderBy(p => p.ProviderName).ToListAsync();
            return _mapper.Map<IEnumerable<SSOProviderResponseDto>>(providers);
        }

        public async Task<bool> DeleteProviderAsync(Guid id)
        {
            var provider = await _context.SSOProviders.FindAsync(id);
            if (provider == null)
                return false;

            _context.SSOProviders.Remove(provider);
            await _context.SaveChangesAsync();
            _logger.LogInformation("Deleted SSO provider: {ProviderName}", provider.ProviderName);

            return true;
        }

        public async Task<bool> ToggleProviderStatusAsync(Guid id)
        {
            var provider = await _context.SSOProviders.FindAsync(id);
            if (provider == null)
                return false;

            provider.IsActive = !provider.IsActive;
            provider.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();

            return true;
        }
    }
}

7. Controllers

csharp
// Controllers/SSOProvidersController.cs
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using SSOManagement.API.Models.DTOs;
using SSOManagement.API.Services;

namespace SSOManagement.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Authorize(Roles = "Admin")] // Only admins can manage SSO configurations
    public class SSOProvidersController : ControllerBase
    {
        private readonly ISSOProviderService _ssoProviderService;
        private readonly ILogger<SSOProvidersController> _logger;

        public SSOProvidersController(
            ISSOProviderService ssoProviderService,
            ILogger<SSOProvidersController> logger)
        {
            _ssoProviderService = ssoProviderService;
            _logger = logger;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<SSOProviderResponseDto>>> GetAllProviders(
            [FromQuery] bool activeOnly = true)
        {
            try
            {
                var providers = await _ssoProviderService.GetAllProvidersAsync(activeOnly);
                return Ok(providers);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving SSO providers");
                return StatusCode(500, "An error occurred while retrieving providers");
            }
        }

        [HttpGet("{id:guid}")]
        public async Task<ActionResult<SSOProviderResponseDto>> GetProviderById(Guid id)
        {
            try
            {
                var provider = await _ssoProviderService.GetProviderByIdAsync(id);
                return Ok(provider);
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving SSO provider {ProviderId}", id);
                return StatusCode(500, "An error occurred while retrieving the provider");
            }
        }

        [HttpGet("by-name/{name}")]
        public async Task<ActionResult<SSOProviderResponseDto>> GetProviderByName(string name)
        {
            try
            {
                var provider = await _ssoProviderService.GetProviderByNameAsync(name);
                return Ok(provider);
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving SSO provider {ProviderName}", name);
                return StatusCode(500, "An error occurred while retrieving the provider");
            }
        }

        [HttpPost]
        public async Task<ActionResult<SSOProviderResponseDto>> CreateProvider(
            [FromBody] SSOProviderDto dto)
        {
            try
            {
                var provider = await _ssoProviderService.CreateProviderAsync(dto);
                return CreatedAtAction(
                    nameof(GetProviderById),
                    new { id = provider.Id },
                    provider);
            }
            catch (InvalidOperationException ex)
            {
                return Conflict(ex.Message);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating SSO provider");
                return StatusCode(500, "An error occurred while creating the provider");
            }
        }

        [HttpPut("{id:guid}")]
        public async Task<ActionResult<SSOProviderResponseDto>> UpdateProvider(
            Guid id,
            [FromBody] SSOProviderDto dto)
        {
            try
            {
                var provider = await _ssoProviderService.UpdateProviderAsync(id, dto);
                return Ok(provider);
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating SSO provider {ProviderId}", id);
                return StatusCode(500, "An error occurred while updating the provider");
            }
        }

        [HttpDelete("{id:guid}")]
        public async Task<ActionResult> DeleteProvider(Guid id)
        {
            try
            {
                var result = await _ssoProviderService.DeleteProviderAsync(id);
                if (!result)
                    return NotFound($"Provider with ID {id} not found");

                return NoContent();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting SSO provider {ProviderId}", id);
                return StatusCode(500, "An error occurred while deleting the provider");
            }
        }

        [HttpPatch("{id:guid}/toggle-status")]
        public async Task<ActionResult> ToggleProviderStatus(Guid id)
        {
            try
            {
                var result = await _ssoProviderService.ToggleProviderStatusAsync(id);
                if (!result)
                    return NotFound($"Provider with ID {id} not found");

                return NoContent();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error toggling SSO provider status {ProviderId}", id);
                return StatusCode(500, "An error occurred while updating provider status");
            }
        }
    }
}

// Controllers/AuthenticationController.cs
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Mvc;
using SSOManagement.API.Models.DTOs;
using SSOManagement.API.Services;

namespace SSOManagement.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthenticationController : ControllerBase
    {
        private readonly ISSOProviderService _ssoProviderService;
        private readonly ILogger<AuthenticationController> _logger;

        public AuthenticationController(
            ISSOProviderService ssoProviderService,
            ILogger<AuthenticationController> logger)
        {
            _ssoProviderService = ssoProviderService;
            _logger = logger;
        }

        [HttpGet("providers")]
        public async Task<ActionResult<IEnumerable<SSOProviderResponseDto>>> GetAvailableProviders()
        {
            var providers = await _ssoProviderService.GetAllProvidersAsync(activeOnly: true);
            return Ok(providers);
        }

        [HttpPost("login/{providerName}")]
        public async Task<IActionResult> Login(string providerName, [FromQuery] string returnUrl = "/")
        {
            try
            {
                var provider = await _ssoProviderService.GetProviderByNameAsync(providerName);
                
                if (!provider.IsActive)
                    return BadRequest($"SSO provider '{providerName}' is not active");

                var properties = new AuthenticationProperties
                {
                    RedirectUri = Url.Action(nameof(Callback)),
                    Items =
                    {
                        { "returnUrl", returnUrl },
                        { "scheme", providerName }
                    }
                };

                return Challenge(properties, providerName);
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error initiating login with provider {ProviderName}", providerName);
                return StatusCode(500, "An error occurred during login");
            }
        }

        [HttpGet("callback")]
        public async Task<IActionResult> Callback()
        {
            var authenticateResult = await HttpContext.AuthenticateAsync();

            if (!authenticateResult.Succeeded)
                return Unauthorized();

            var returnUrl = authenticateResult.Properties.Items["returnUrl"] ?? "/";
            return Redirect(returnUrl);
        }

        [HttpPost("logout")]
        public async Task<IActionResult> Logout()
        {
            await HttpContext.SignOutAsync();
            return Ok(new { message = "Logged out successfully" });
        }
    }
}

8. Program.cs Configuration

csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using SSOManagement.API.Data;
using SSOManagement.API.Services;
using System.Reflection;

var builder = WebApplication.CreateBuilder(args);

// PostgreSQL Configuration
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

// Services
builder.Services.AddScoped<ISSOProviderService, SSOProviderService>();
builder.Services.AddSingleton<IEncryptionService, EncryptionService>();

// AutoMapper
builder.Services.AddAutoMapper(Assembly.GetExecutingAssembly());

// Authentication
builder.Services.AddAuthentication(options =>
{
    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.Authority = builder.Configuration["Jwt:Authority"];
    options.Audience = builder.Configuration["Jwt:Audience"];
});

// CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowUI", policy =>
    {
        policy.WithOrigins(builder.Configuration.GetSection("AllowedOrigins").Get<string[]>())
            .AllowAnyHeader()
            .AllowAnyMethod()
            .AllowCredentials();
    });
});

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseCors("AllowUI");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();

9. appsettings.json

json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Database=sso_management;Username=postgres;Password=yourpassword"
  },
  "Encryption": {
    "Key": "YOUR_BASE64_ENCODED_32_BYTE_KEY",
    "IV": "YOUR_BASE64_ENCODED_16_BYTE_IV"
  },
  "Jwt": {
    "Authority": "https://your-auth-server.com",
    "Audience": "sso-management-api"
  },
  "AllowedOrigins": [
    "http://localhost:3000",
    "https://your-ui-app.com"
  ],
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}



// Configuration/MappingProfile.cs
using AutoMapper;
using SSOManagement.API.Models.Entities;
using SSOManagement.API.Models.DTOs;

namespace SSOManagement.API.Configuration
{
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            // SSOProvider mappings
            CreateMap<SSOProvider, SSOProviderResponseDto>()
                .ForMember(dest => dest.Id, opt => opt.MapFrom(src => src.Id))
                .ForMember(dest => dest.ProviderName, opt => opt.MapFrom(src => src.ProviderName))
                .ForMember(dest => dest.ProviderType, opt => opt.MapFrom(src => src.ProviderType))
                .ForMember(dest => dest.ClientId, opt => opt.MapFrom(src => src.ClientId))
                .ForMember(dest => dest.Authority, opt => opt.MapFrom(src => src.Authority))
                .ForMember(dest => dest.GrantType, opt => opt.MapFrom(src => src.GrantType))
                .ForMember(dest => dest.Scope, opt => opt.MapFrom(src => src.Scope))
                .ForMember(dest => dest.RedirectUri, opt => opt.MapFrom(src => src.RedirectUri))
                .ForMember(dest => dest.IsActive, opt => opt.MapFrom(src => src.IsActive))
                .ForMember(dest => dest.CreatedAt, opt => opt.MapFrom(src => src.CreatedAt))
                .ForMember(dest => dest.UpdatedAt, opt => opt.MapFrom(src => src.UpdatedAt));
                // Note: ClientSecret is intentionally NOT mapped to response DTO

            CreateMap<SSOProviderDto, SSOProvider>()
                .ForMember(dest => dest.Id, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.Settings, opt => opt.Ignore())
                .ForMember(dest => dest.UserMappings, opt => opt.Ignore());

            // SSOProviderSetting mappings
            CreateMap<SSOProviderSetting, Dictionary<string, string>>()
                .ConvertUsing((src, dest, context) =>
                {
                    dest = dest ?? new Dictionary<string, string>();
                    dest[src.SettingKey] = src.SettingValue;
                    return dest;
                });

            // UserSSOMapping mappings (if needed)
            CreateMap<UserSSOMapping, UserSSOMapping>();
        }
    }
}




Key Features
Security Best Practices​

    Client secrets are encrypted using AES encryption before storage in PostgreSQL

    Secrets are never returned in API responses

    Role-based authorization for SSO configuration management

    Audit logging for all SSO activities

    Use Azure Key Vault or AWS Secrets Manager for encryption keys in production

Dynamic Authentication

ASP.NET Core supports multiple authentication handlers that can be registered dynamically, allowing users to select their preferred SSO provider at login time.
Extensibility

The additional settings table allows storing provider-specific configurations without schema changes, supporting various OAuth2, OpenID Connect, and SAML providers.
Multi-Tenant Support​

The architecture supports multiple organizations/tenants, each with their own SSO configurations, making it suitable for SaaS applications.

This solution provides a production-ready foundation for managing multiple SSO providers with secure credential storage, flexible configuration, and a clean API interface for your UI application.




Solution: Dynamic Authentication Scheme Registration
1. Create Dynamic Authentication Options Provider

csharp
// Services/IDynamicAuthenticationSchemeProvider.cs
namespace SSOManagement.API.Services
{
    public interface IDynamicAuthenticationSchemeProvider
    {
        Task LoadProvidersAsync();
        Task AddOrUpdateProviderAsync(string schemeName);
        Task RemoveProviderAsync(string schemeName);
    }
}

// Services/DynamicAuthenticationSchemeProvider.cs
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.OAuth;
using Microsoft.AspNetCore.Authentication.OpenIdConnect;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Options;
using SSOManagement.API.Data;

namespace SSOManagement.API.Services
{
    public class DynamicAuthenticationSchemeProvider : IDynamicAuthenticationSchemeProvider
    {
        private readonly IAuthenticationSchemeProvider _schemeProvider;
        private readonly IOptionsMonitorCache<OAuthOptions> _oauthOptionsCache;
        private readonly IOptionsMonitorCache<OpenIdConnectOptions> _oidcOptionsCache;
        private readonly ApplicationDbContext _context;
        private readonly IEncryptionService _encryptionService;
        private readonly ILogger<DynamicAuthenticationSchemeProvider> _logger;

        public DynamicAuthenticationSchemeProvider(
            IAuthenticationSchemeProvider schemeProvider,
            IOptionsMonitorCache<OAuthOptions> oauthOptionsCache,
            IOptionsMonitorCache<OpenIdConnectOptions> oidcOptionsCache,
            ApplicationDbContext context,
            IEncryptionService encryptionService,
            ILogger<DynamicAuthenticationSchemeProvider> logger)
        {
            _schemeProvider = schemeProvider;
            _oauthOptionsCache = oauthOptionsCache;
            _oidcOptionsCache = oidcOptionsCache;
            _context = context;
            _encryptionService = encryptionService;
            _logger = logger;
        }

        public async Task LoadProvidersAsync()
        {
            var providers = await _context.SSOProviders
                .Where(p => p.IsActive)
                .ToListAsync();

            foreach (var provider in providers)
            {
                try
                {
                    await RegisterSchemeAsync(provider);
                    _logger.LogInformation("Loaded SSO provider: {ProviderName}", provider.ProviderName);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to load SSO provider: {ProviderName}", provider.ProviderName);
                }
            }
        }

        public async Task AddOrUpdateProviderAsync(string schemeName)
        {
            var provider = await _context.SSOProviders
                .FirstOrDefaultAsync(p => p.ProviderName == schemeName && p.IsActive);

            if (provider == null)
            {
                await RemoveProviderAsync(schemeName);
                return;
            }

            // Remove existing scheme if it exists
            var existingScheme = await _schemeProvider.GetSchemeAsync(schemeName);
            if (existingScheme != null)
            {
                await RemoveProviderAsync(schemeName);
            }

            await RegisterSchemeAsync(provider);
        }

        public async Task RemoveProviderAsync(string schemeName)
        {
            var scheme = await _schemeProvider.GetSchemeAsync(schemeName);
            if (scheme != null)
            {
                if (_schemeProvider is IAuthenticationSchemeProvider dynamicProvider)
                {
                    _schemeProvider.RemoveScheme(schemeName);
                }

                // Clear options cache
                _oauthOptionsCache.TryRemove(schemeName);
                _oidcOptionsCache.TryRemove(schemeName);
            }
        }

        private async Task RegisterSchemeAsync(Models.Entities.SSOProvider provider)
        {
            var decryptedSecret = _encryptionService.Decrypt(provider.ClientSecret);

            switch (provider.ProviderType.ToLowerInvariant())
            {
                case "oauth2":
                    RegisterOAuth2Scheme(provider, decryptedSecret);
                    break;

                case "openidconnect":
                case "oidc":
                    RegisterOpenIdConnectScheme(provider, decryptedSecret);
                    break;

                default:
                    throw new NotSupportedException($"Provider type '{provider.ProviderType}' is not supported");
            }

            await Task.CompletedTask;
        }

        private void RegisterOAuth2Scheme(Models.Entities.SSOProvider provider, string clientSecret)
        {
            var options = new OAuthOptions
            {
                ClientId = provider.ClientId,
                ClientSecret = clientSecret,
                CallbackPath = new PathString("/api/authentication/callback"),
                AuthorizationEndpoint = $"{provider.Authority}/authorize",
                TokenEndpoint = $"{provider.Authority}/token",
                UserInformationEndpoint = $"{provider.Authority}/userinfo",
                SaveTokens = true
            };

            // Add scopes
            if (!string.IsNullOrEmpty(provider.Scope))
            {
                foreach (var scope in provider.Scope.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                {
                    options.Scope.Add(scope);
                }
            }

            // Register the scheme dynamically
            _schemeProvider.AddScheme(new AuthenticationScheme(
                provider.ProviderName,
                provider.ProviderName,
                typeof(OAuthHandler<OAuthOptions>)
            ));

            // Cache the options
            _oauthOptionsCache.TryAdd(provider.ProviderName, options);
        }

        private void RegisterOpenIdConnectScheme(Models.Entities.SSOProvider provider, string clientSecret)
        {
            var options = new OpenIdConnectOptions
            {
                ClientId = provider.ClientId,
                ClientSecret = clientSecret,
                Authority = provider.Authority,
                CallbackPath = new PathString("/api/authentication/callback"),
                ResponseType = "code",
                SaveTokens = true,
                GetClaimsFromUserInfoEndpoint = true
            };

            // Add scopes
            if (!string.IsNullOrEmpty(provider.Scope))
            {
                options.Scope.Clear();
                foreach (var scope in provider.Scope.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                {
                    options.Scope.Add(scope);
                }
            }

            // Use metadata URL if available
            if (!string.IsNullOrEmpty(provider.MetadataUrl))
            {
                options.MetadataAddress = provider.MetadataUrl;
            }

            // Register the scheme dynamically
            _schemeProvider.AddScheme(new AuthenticationScheme(
                provider.ProviderName,
                provider.ProviderName,
                typeof(OpenIdConnectHandler)
            ));

            // Cache the options
            _oidcOptionsCache.TryAdd(provider.ProviderName, options);
        }
    }
}

2. Update Program.cs

Register the dynamic authentication provider:

csharp
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.AspNetCore.Authentication.OAuth;
using Microsoft.AspNetCore.Authentication.OpenIdConnect;
using Microsoft.EntityFrameworkCore;
using SSOManagement.API.Data;
using SSOManagement.API.Services;
using SSOManagement.API.Configuration;

var builder = WebApplication.CreateBuilder(args);

// PostgreSQL Configuration
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

// Services
builder.Services.AddScoped<ISSOProviderService, SSOProviderService>();
builder.Services.AddSingleton<IEncryptionService, EncryptionService>();
builder.Services.AddScoped<IDynamicAuthenticationSchemeProvider, DynamicAuthenticationSchemeProvider>();

// AutoMapper
builder.Services.AddAutoMapper(typeof(Program).Assembly);

// Authentication - Base configuration
builder.Services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme;
})
.AddCookie(options =>
{
    options.LoginPath = "/api/authentication/login";
    options.LogoutPath = "/api/authentication/logout";
    options.ExpireTimeSpan = TimeSpan.FromHours(8);
    options.SlidingExpiration = true;
});

// CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowUI", policy =>
    {
        policy.WithOrigins(builder.Configuration.GetSection("AllowedOrigins").Get<string[]>() ?? new[] { "http://localhost:3000" })
            .AllowAnyHeader()
            .AllowAnyMethod()
            .AllowCredentials();
    });
});

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Load dynamic authentication providers at startup
using (var scope = app.Services.CreateScope())
{
    var dynamicAuthProvider = scope.ServiceProvider.GetRequiredService<IDynamicAuthenticationSchemeProvider>();
    await dynamicAuthProvider.LoadProvidersAsync();
}

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseCors("AllowUI");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();

3. Update SSOProviderService to Reload Schemes

Modify the service to reload authentication schemes when providers are added/updated:​

csharp
// Services/SSOProviderService.cs (Updated methods)
public class SSOProviderService : ISSOProviderService
{
    private readonly ApplicationDbContext _context;
    private readonly IEncryptionService _encryptionService;
    private readonly ILogger<SSOProviderService> _logger;
    private readonly IDynamicAuthenticationSchemeProvider _dynamicAuthProvider;

    public SSOProviderService(
        ApplicationDbContext context,
        IEncryptionService encryptionService,
        ILogger<SSOProviderService> logger,
        IDynamicAuthenticationSchemeProvider dynamicAuthProvider)
    {
        _context = context;
        _encryptionService = encryptionService;
        _logger = logger;
        _dynamicAuthProvider = dynamicAuthProvider;
    }

    public async Task<SSOProviderResponseDto> CreateProviderAsync(SSOProviderDto dto)
    {
        var existingProvider = await _context.SSOProviders
            .FirstOrDefaultAsync(p => p.ProviderName == dto.ProviderName);

        if (existingProvider != null)
            throw new InvalidOperationException($"Provider '{dto.ProviderName}' already exists");

        var provider = new SSOProvider
        {
            ProviderName = dto.ProviderName,
            ProviderType = dto.ProviderType,
            ClientId = dto.ClientId,
            ClientSecret = _encryptionService.Encrypt(dto.ClientSecret),
            Authority = dto.Authority,
            GrantType = dto.GrantType,
            Scope = dto.Scope,
            RedirectUri = dto.RedirectUri,
            MetadataUrl = dto.MetadataUrl,
            IsActive = dto.IsActive,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.SSOProviders.Add(provider);
        await _context.SaveChangesAsync();

        // Dynamically register the authentication scheme
        if (provider.IsActive)
        {
            await _dynamicAuthProvider.AddOrUpdateProviderAsync(provider.ProviderName);
        }

        _logger.LogInformation("Created SSO provider: {ProviderName}", provider.ProviderName);

        return MapToResponseDto(provider);
    }

    public async Task<SSOProviderResponseDto> UpdateProviderAsync(Guid id, SSOProviderDto dto)
    {
        var provider = await _context.SSOProviders.FindAsync(id);

        if (provider == null)
            throw new KeyNotFoundException($"Provider with ID {id} not found");

        provider.ProviderName = dto.ProviderName;
        provider.ProviderType = dto.ProviderType;
        provider.ClientId = dto.ClientId;
        
        if (!string.IsNullOrEmpty(dto.ClientSecret))
            provider.ClientSecret = _encryptionService.Encrypt(dto.ClientSecret);

        provider.Authority = dto.Authority;
        provider.GrantType = dto.GrantType;
        provider.Scope = dto.Scope;
        provider.RedirectUri = dto.RedirectUri;
        provider.MetadataUrl = dto.MetadataUrl;
        provider.IsActive = dto.IsActive;
        provider.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        // Reload the authentication scheme
        await _dynamicAuthProvider.AddOrUpdateProviderAsync(provider.ProviderName);

        _logger.LogInformation("Updated SSO provider: {ProviderName}", provider.ProviderName);

        return MapToResponseDto(provider);
    }

    public async Task<bool> DeleteProviderAsync(Guid id)
    {
        var provider = await _context.SSOProviders.FindAsync(id);
        if (provider == null)
            return false;

        var providerName = provider.ProviderName;
        _context.SSOProviders.Remove(provider);
        await _context.SaveChangesAsync();

        // Remove the authentication scheme
        await _dynamicAuthProvider.RemoveProviderAsync(providerName);

        _logger.LogInformation("Deleted SSO provider: {ProviderName}", providerName);
        return true;
    }

    public async Task<bool> ToggleProviderStatusAsync(Guid id)
    {
        var provider = await _context.SSOProviders.FindAsync(id);
        if (provider == null)
            return false;

        provider.IsActive = !provider.IsActive;
        provider.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();

        // Reload or remove the authentication scheme
        await _dynamicAuthProvider.AddOrUpdateProviderAsync(provider.ProviderName);

        return true;
    }

    private SSOProviderResponseDto MapToResponseDto(SSOProvider provider)
    {
        return new SSOProviderResponseDto
        {
            Id = provider.Id,
            ProviderName = provider.ProviderName,
            ProviderType = provider.ProviderType,
            ClientId = provider.ClientId,
            Authority = provider.Authority,
            GrantType = provider.GrantType,
            Scope = provider.Scope,
            RedirectUri = provider.RedirectUri,
            IsActive = provider.IsActive,
            CreatedAt = provider.CreatedAt,
            UpdatedAt = provider.UpdatedAt
        };
    }

    // Implement other methods...
}

4. Alternative: Simpler Approach with PostConfigure

If the above is too complex, use a simpler approach with PostConfigure:​

csharp
// Configuration/DynamicAuthenticationPostConfigureOptions.cs
using Microsoft.AspNetCore.Authentication.OAuth;
using Microsoft.AspNetCore.Authentication.OpenIdConnect;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Options;
using SSOManagement.API.Data;
using SSOManagement.API.Services;

namespace SSOManagement.API.Configuration
{
    public class DynamicOAuthPostConfigureOptions : IPostConfigureOptions<OAuthOptions>
    {
        private readonly IServiceProvider _serviceProvider;

        public DynamicOAuthPostConfigureOptions(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }

        public void PostConfigure(string name, OAuthOptions options)
        {
            using var scope = _serviceProvider.CreateScope();
            var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
            var encryption = scope.ServiceProvider.GetRequiredService<IEncryptionService>();

            var provider = context.SSOProviders
                .FirstOrDefault(p => p.ProviderName == name && p.IsActive);

            if (provider != null && provider.ProviderType.ToLowerInvariant() == "oauth2")
            {
                options.ClientId = provider.ClientId;
                options.ClientSecret = encryption.Decrypt(provider.ClientSecret);
                options.AuthorizationEndpoint = $"{provider.Authority}/authorize";
                options.TokenEndpoint = $"{provider.Authority}/token";
                options.UserInformationEndpoint = $"{provider.Authority}/userinfo";

                if (!string.IsNullOrEmpty(provider.Scope))
                {
                    options.Scope.Clear();
                    foreach (var scope in provider.Scope.Split(' '))
                    {
                        options.Scope.Add(scope);
                    }
                }
            }
        }
    }

    public class DynamicOpenIdConnectPostConfigureOptions : IPostConfigureOptions<OpenIdConnectOptions>
    {
        private readonly IServiceProvider _serviceProvider;

        public DynamicOpenIdConnectPostConfigureOptions(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }

        public void PostConfigure(string name, OpenIdConnectOptions options)
        {
            using var scope = _serviceProvider.CreateScope();
            var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
            var encryption = scope.ServiceProvider.GetRequiredService<IEncryptionService>();

            var provider = context.SSOProviders
                .FirstOrDefault(p => p.ProviderName == name && p.IsActive);

            if (provider != null && 
                (provider.ProviderType.ToLowerInvariant() == "openidconnect" || 
                 provider.ProviderType.ToLowerInvariant() == "oidc"))
            {
                options.ClientId = provider.ClientId;
                options.ClientSecret = encryption.Decrypt(provider.ClientSecret);
                options.Authority = provider.Authority;
                
                if (!string.IsNullOrEmpty(provider.MetadataUrl))
                {
                    options.MetadataAddress = provider.MetadataUrl;
                }

                if (!string.IsNullOrEmpty(provider.Scope))
                {
                    options.Scope.Clear();
                    foreach (var scope in provider.Scope.Split(' '))
                    {
                        options.Scope.Add(scope);
                    }
                }
            }
        }
    }
}

// Update Program.cs
builder.Services.AddSingleton<IPostConfigureOptions<OAuthOptions>, DynamicOAuthPostConfigureOptions>();
builder.Services.AddSingleton<IPostConfigureOptions<OpenIdConnectOptions>, DynamicOpenIdConnectPostConfigureOptions>();

Testing

After implementing, test with:

bash
# 1. Create a provider
curl -X POST https://localhost:5001/api/ssoproviders \
  -H "Content-Type: application/json" \
  -d '{"providerName":"AzureAD","providerType":"OpenIdConnect",...}'

# 2. Test login
curl https://localhost:5001/api/authentication/login/AzureAD

The first approach (DynamicAuthenticationSchemeProvider) gives you full control over scheme registration, while the second approach (PostConfigure) is simpler but has some limitations. Choose based on your complexity needs.
