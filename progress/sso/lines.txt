I'll update the implementation for PostgreSQL and add Duo MFA integration alongside TOTP support.
Updated Database Schema (PostgreSQL)
Step 1: PostgreSQL Schema Design

sql
-- PostgreSQL Database Schema
-- Using shared database, shared schema with Row-Level Security (RLS)

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tenant SSO Configuration Table
CREATE TABLE tenant_sso_configuration (
    id SERIAL PRIMARY KEY,
    tenant_id VARCHAR(100) NOT NULL UNIQUE,
    tenant_name VARCHAR(255) NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    
    -- SSO Settings
    sso_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    mfa_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    allow_both_sso_and_mfa BOOLEAN NOT NULL DEFAULT TRUE,
    
    -- OIDC Configuration
    authority VARCHAR(500),
    client_id VARCHAR(255),
    client_secret TEXT, -- Encrypted
    redirect_uri VARCHAR(500),
    post_logout_redirect_uri VARCHAR(500),
    scope VARCHAR(500) DEFAULT 'openid profile email',
    response_type VARCHAR(50) DEFAULT 'code',
    
    -- Additional Settings
    metadata_url VARCHAR(500),
    require_https_metadata BOOLEAN DEFAULT TRUE,
    
    -- MFA Provider Settings
    mfa_provider VARCHAR(50) DEFAULT 'TOTP', -- 'TOTP', 'DUO', 'BOTH'
    duo_client_id VARCHAR(255),
    duo_client_secret TEXT, -- Encrypted
    duo_api_host VARCHAR(255),
    
    -- Audit Fields
    created_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100),
    updated_by VARCHAR(100)
);

-- User Authentication Method
CREATE TABLE user_authentication_method (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    tenant_id VARCHAR(100) NOT NULL,
    auth_method VARCHAR(50) NOT NULL, -- 'SSO', 'MFA', 'Password'
    mfa_provider VARCHAR(50), -- 'TOTP', 'DUO'
    is_default BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- TOTP Settings
    totp_secret TEXT,
    totp_backup_codes JSONB,
    
    -- Duo Settings
    duo_user_id VARCHAR(255),
    duo_username VARCHAR(255),
    
    last_used_date TIMESTAMPTZ,
    created_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    FOREIGN KEY (tenant_id) REFERENCES tenant_sso_configuration(tenant_id)
);

-- SSO Login Audit
CREATE TABLE sso_audit_log (
    id SERIAL PRIMARY KEY,
    tenant_id VARCHAR(100) NOT NULL,
    user_id INTEGER,
    email VARCHAR(255),
    login_status VARCHAR(50), -- 'Success', 'Failed', 'MFA_Required'
    mfa_provider VARCHAR(50),
    idp_response TEXT,
    login_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ip_address VARCHAR(50)
);

-- Indexes for performance
CREATE INDEX idx_tenant_sso_tenant_id ON tenant_sso_configuration(tenant_id);
CREATE INDEX idx_user_auth_user_tenant ON user_authentication_method(user_id, tenant_id);
CREATE INDEX idx_sso_audit_tenant_date ON sso_audit_log(tenant_id, login_date DESC);

-- Function to update timestamp
CREATE OR REPLACE FUNCTION update_updated_date_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_date = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-update updated_date
CREATE TRIGGER update_tenant_sso_updated_date
    BEFORE UPDATE ON tenant_sso_configuration
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_date_column();

-- Optional: Enable Row-Level Security for multi-tenancy
ALTER TABLE user_authentication_method ENABLE ROW LEVEL SECURITY;

-- Create policy (example - adjust based on your authentication)
CREATE POLICY tenant_isolation_policy ON user_authentication_method
    USING (tenant_id = current_setting('app.current_tenant', true)::VARCHAR);

Updated Backend Implementation (.NET)
Step 2: Update NuGet Packages

xml
<ItemGroup>
  <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />
  <PackageReference Include="Microsoft.AspNetCore.Authentication.OpenIdConnect" Version="8.0.0" />
  <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.0" />
  <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0" />
  <PackageReference Include="Microsoft.IdentityModel.Tokens" Version="7.0.0" />
  <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="7.0.0" />
  <PackageReference Include="Otp.NET" Version="1.3.0" />
  <PackageReference Include="DuoUniversal" Version="1.3.0" />
  <PackageReference Include="QRCoder" Version="1.4.3" />
</ItemGroup>

Step 3: Updated Models for PostgreSQL and Duo

csharp
// Models/TenantSSOConfiguration.cs
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace YourApp.Models
{
    [Table("tenant_sso_configuration")]
    public class TenantSSOConfiguration
    {
        [Key]
        [Column("id")]
        public int Id { get; set; }
        
        [Required]
        [Column("tenant_id")]
        public string TenantId { get; set; }
        
        [Required]
        [Column("tenant_name")]
        public string TenantName { get; set; }
        
        [Column("is_active")]
        public bool IsActive { get; set; } = true;
        
        [Column("sso_enabled")]
        public bool SSOEnabled { get; set; }
        
        [Column("mfa_enabled")]
        public bool MFAEnabled { get; set; }
        
        [Column("allow_both_sso_and_mfa")]
        public bool AllowBothSSOAndMFA { get; set; } = true;
        
        [Column("authority")]
        public string Authority { get; set; }
        
        [Column("client_id")]
        public string ClientId { get; set; }
        
        [Column("client_secret")]
        public string ClientSecret { get; set; }
        
        [Column("redirect_uri")]
        public string RedirectUri { get; set; }
        
        [Column("post_logout_redirect_uri")]
        public string PostLogoutRedirectUri { get; set; }
        
        [Column("scope")]
        public string Scope { get; set; } = "openid profile email";
        
        [Column("response_type")]
        public string ResponseType { get; set; } = "code";
        
        [Column("metadata_url")]
        public string MetadataUrl { get; set; }
        
        [Column("require_https_metadata")]
        public bool RequireHttpsMetadata { get; set; } = true;
        
        // Duo MFA Settings
        [Column("mfa_provider")]
        public string MFAProvider { get; set; } = "TOTP"; // TOTP, DUO, BOTH
        
        [Column("duo_client_id")]
        public string DuoClientId { get; set; }
        
        [Column("duo_client_secret")]
        public string DuoClientSecret { get; set; }
        
        [Column("duo_api_host")]
        public string DuoApiHost { get; set; }
        
        [Column("created_date")]
        public DateTime CreatedDate { get; set; } = DateTime.UtcNow;
        
        [Column("updated_date")]
        public DateTime UpdatedDate { get; set; } = DateTime.UtcNow;
    }
    
    [Table("user_authentication_method")]
    public class UserAuthenticationMethod
    {
        [Key]
        [Column("id")]
        public int Id { get; set; }
        
        [Column("user_id")]
        public int UserId { get; set; }
        
        [Column("tenant_id")]
        public string TenantId { get; set; }
        
        [Column("auth_method")]
        public string AuthMethod { get; set; }
        
        [Column("mfa_provider")]
        public string MFAProvider { get; set; }
        
        [Column("is_default")]
        public bool IsDefault { get; set; }
        
        // TOTP
        [Column("totp_secret")]
        public string TotpSecret { get; set; }
        
        [Column("totp_backup_codes")]
        public string TotpBackupCodes { get; set; } // JSON string
        
        // Duo
        [Column("duo_user_id")]
        public string DuoUserId { get; set; }
        
        [Column("duo_username")]
        public string DuoUsername { get; set; }
        
        [Column("last_used_date")]
        public DateTime? LastUsedDate { get; set; }
        
        [Column("created_date")]
        public DateTime CreatedDate { get; set; } = DateTime.UtcNow;
    }

    [Table("sso_audit_log")]
    public class SSOAuditLog
    {
        [Key]
        [Column("id")]
        public int Id { get; set; }
        
        [Column("tenant_id")]
        public string TenantId { get; set; }
        
        [Column("user_id")]
        public int? UserId { get; set; }
        
        [Column("email")]
        public string Email { get; set; }
        
        [Column("login_status")]
        public string LoginStatus { get; set; }
        
        [Column("mfa_provider")]
        public string MFAProvider { get; set; }
        
        [Column("idp_response")]
        public string IdpResponse { get; set; }
        
        [Column("login_date")]
        public DateTime LoginDate { get; set; } = DateTime.UtcNow;
        
        [Column("ip_address")]
        public string IpAddress { get; set; }
    }
}

Step 4: Updated DbContext for PostgreSQL

csharp
// Data/ApplicationDbContext.cs
using Microsoft.EntityFrameworkCore;
using YourApp.Models;
using Npgsql;

namespace YourApp.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        public DbSet<TenantSSOConfiguration> TenantSSOConfigurations { get; set; }
        public DbSet<UserAuthenticationMethod> UserAuthenticationMethods { get; set; }
        public DbSet<SSOAuditLog> SSOAuditLogs { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Configure PostgreSQL-specific settings
            modelBuilder.Entity<TenantSSOConfiguration>()
                .HasIndex(t => t.TenantId)
                .IsUnique();

            modelBuilder.Entity<UserAuthenticationMethod>()
                .HasIndex(u => new { u.UserId, u.TenantId });

            // Configure JSONB column for PostgreSQL
            modelBuilder.Entity<UserAuthenticationMethod>()
                .Property(u => u.TotpBackupCodes)
                .HasColumnType("jsonb");
        }
    }
}

Step 5: Duo MFA Service

csharp
// Services/IDuoService.cs
namespace YourApp.Services
{
    public interface IDuoService
    {
        Task<string> GenerateDuoAuthUrlAsync(string username, string tenantId);
        Task<DuoAuthResult> ValidateDuoCallbackAsync(string duoCode, string state, string tenantId);
        Task<bool> EnrollUserInDuoAsync(string username, string email, string tenantId);
    }

    public class DuoAuthResult
    {
        public bool Success { get; set; }
        public string Username { get; set; }
        public string ErrorMessage { get; set; }
    }
}

// Services/DuoService.cs
using DuoUniversal;
using Microsoft.Extensions.Caching.Memory;
using YourApp.Models;

namespace YourApp.Services
{
    public class DuoService : IDuoService
    {
        private readonly ITenantSSOService _tenantService;
        private readonly IMemoryCache _cache;
        private readonly ILogger<DuoService> _logger;
        private readonly IHttpContextAccessor _httpContextAccessor;

        public DuoService(
            ITenantSSOService tenantService,
            IMemoryCache cache,
            ILogger<DuoService> logger,
            IHttpContextAccessor httpContextAccessor)
        {
            _tenantService = tenantService;
            _cache = cache;
            _logger = logger;
            _httpContextAccessor = httpContextAccessor;
        }

        public async Task<string> GenerateDuoAuthUrlAsync(string username, string tenantId)
        {
            try
            {
                var config = await _tenantService.GetTenantConfigurationAsync(tenantId);
                if (config == null || string.IsNullOrEmpty(config.DuoClientId))
                {
                    throw new InvalidOperationException("Duo not configured for this tenant");
                }

                var client = CreateDuoClient(config);
                
                // Generate state token for CSRF protection
                var state = Guid.NewGuid().ToString();
                
                // Store state in cache with username and tenantId
                _cache.Set($"duo_state_{state}", new { username, tenantId }, TimeSpan.FromMinutes(5));

                // Generate authorization URL
                var authUrl = client.GenerateAuthUrl(username, state);
                
                return authUrl;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating Duo auth URL for user {Username}", username);
                throw;
            }
        }

        public async Task<DuoAuthResult> ValidateDuoCallbackAsync(string duoCode, string state, string tenantId)
        {
            try
            {
                // Validate state
                if (!_cache.TryGetValue($"duo_state_{state}", out dynamic stateData))
                {
                    return new DuoAuthResult
                    {
                        Success = false,
                        ErrorMessage = "Invalid or expired state"
                    };
                }

                var config = await _tenantService.GetTenantConfigurationAsync(tenantId);
                if (config == null)
                {
                    return new DuoAuthResult
                    {
                        Success = false,
                        ErrorMessage = "Invalid tenant configuration"
                    };
                }

                var client = CreateDuoClient(config);
                
                // Exchange code for authentication result
                var result = await client.ExchangeAuthorizationCodeFor2faResult(duoCode, (string)stateData.username);
                
                // Remove state from cache
                _cache.Remove($"duo_state_{state}");

                return new DuoAuthResult
                {
                    Success = true,
                    Username = result.AuthResult.Username
                };
            }
            catch (DuoException ex)
            {
                _logger.LogError(ex, "Duo authentication failed");
                return new DuoAuthResult
                {
                    Success = false,
                    ErrorMessage = ex.Message
                };
            }
        }

        public async Task<bool> EnrollUserInDuoAsync(string username, string email, string tenantId)
        {
            try
            {
                var config = await _tenantService.GetTenantConfigurationAsync(tenantId);
                if (config == null || string.IsNullOrEmpty(config.DuoClientId))
                {
                    return false;
                }

                // Duo Universal Prompt handles enrollment automatically during first auth
                // This method can be used for pre-enrollment via Admin API if needed
                _logger.LogInformation("User {Username} will be enrolled during first Duo authentication", username);
                
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error enrolling user {Username} in Duo", username);
                return false;
            }
        }

        private Client CreateDuoClient(TenantSSOConfiguration config)
        {
            var request = _httpContextAccessor.HttpContext.Request;
            var redirectUrl = $"{request.Scheme}://{request.Host}/api/auth/duo-callback";

            var clientBuilder = new ClientBuilder(
                config.DuoClientId,
                config.DuoClientSecret,
                config.DuoApiHost,
                redirectUrl
            );

            return clientBuilder.Build();
        }
    }
}

Step 6: Updated Auth Controller with Duo Support

csharp
// Controllers/AuthController.cs (Updated sections)
using DuoUniversal;
using OtpNet;
using QRCoder;

namespace YourApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthController : ControllerBase
    {
        private readonly ITenantSSOService _ssoService;
        private readonly IDuoService _duoService;
        private readonly ApplicationDbContext _context;
        private readonly IConfiguration _configuration;
        private readonly ILogger<AuthController> _logger;

        public AuthController(
            ITenantSSOService ssoService,
            IDuoService duoService,
            ApplicationDbContext context,
            IConfiguration configuration,
            ILogger<AuthController> logger)
        {
            _ssoService = ssoService;
            _duoService = duoService;
            _context = context;
            _configuration = configuration;
            _logger = logger;
        }

        [HttpGet("tenant-config/{tenantId}")]
        public async Task<IActionResult> GetTenantConfig(string tenantId)
        {
            try
            {
                var config = await _ssoService.GetTenantConfigurationAsync(tenantId);
                if (config == null)
                {
                    return NotFound(new { message = "Tenant configuration not found" });
                }

                return Ok(new
                {
                    tenantId = config.TenantId,
                    tenantName = config.TenantName,
                    ssoEnabled = config.SSOEnabled,
                    mfaEnabled = config.MFAEnabled,
                    mfaProvider = config.MFAProvider,
                    allowBothSSOAndMFA = config.AllowBothSSOAndMFA,
                    authority = config.Authority,
                    clientId = config.ClientId,
                    redirectUri = config.RedirectUri,
                    postLogoutRedirectUri = config.PostLogoutRedirectUri,
                    scope = config.Scope,
                    responseType = config.ResponseType,
                    duoEnabled = !string.IsNullOrEmpty(config.DuoClientId)
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving tenant configuration");
                return StatusCode(500, new { message = "Internal server error" });
            }
        }

        [HttpPost("mfa/setup")]
        public async Task<IActionResult> SetupMFA([FromBody] MFASetupRequest request)
        {
            try
            {
                var config = await _ssoService.GetTenantConfigurationAsync(request.TenantId);
                if (config == null || !config.MFAEnabled)
                {
                    return BadRequest(new { message = "MFA not enabled for this tenant" });
                }

                var response = new MFASetupResponse();

                // TOTP Setup
                if (config.MFAProvider == "TOTP" || config.MFAProvider == "BOTH")
                {
                    var totpSecret = GenerateTOTPSecret();
                    var qrCodeUrl = GenerateQRCodeUrl(request.Email, totpSecret, config.TenantName);
                    var qrCodeImage = GenerateQRCodeImage(qrCodeUrl);

                    response.TotpSecret = totpSecret;
                    response.TotpQrCodeUrl = qrCodeUrl;
                    response.TotpQrCodeBase64 = qrCodeImage;
                    response.TotpAvailable = true;
                }

                // Duo Setup
                if (config.MFAProvider == "DUO" || config.MFAProvider == "BOTH")
                {
                    await _duoService.EnrollUserInDuoAsync(request.Email, request.Email, request.TenantId);
                    response.DuoAvailable = true;
                    response.DuoEnrollmentMessage = "Duo enrollment will be completed during first authentication";
                }

                return Ok(response);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "MFA setup error");
                return StatusCode(500, new { message = "MFA setup failed" });
            }
        }

        [HttpPost("mfa/initiate-duo")]
        public async Task<IActionResult> InitiateDuoAuth([FromBody] DuoInitiateRequest request)
        {
            try
            {
                var authUrl = await _duoService.GenerateDuoAuthUrlAsync(request.Username, request.TenantId);
                
                return Ok(new
                {
                    authUrl,
                    message = "Redirect user to this URL for Duo authentication"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error initiating Duo authentication");
                return StatusCode(500, new { message = "Failed to initiate Duo authentication" });
            }
        }

        [HttpGet("duo-callback")]
        public async Task<IActionResult> DuoCallback([FromQuery] string duo_code, [FromQuery] string state)
        {
            try
            {
                // Extract tenantId from state (you may encode it differently)
                var tenantId = HttpContext.Request.Query["tenant_id"].ToString();
                
                var result = await _duoService.ValidateDuoCallbackAsync(duo_code, state, tenantId);
                
                if (!result.Success)
                {
                    return Redirect($"/login?error={Uri.EscapeDataString(result.ErrorMessage)}");
                }

                // Generate JWT token
                var token = GenerateJwtToken(tenantId, result.Username, result.Username);

                await _ssoService.LogSSOAttemptAsync(
                    tenantId,
                    result.Username,
                    "Success",
                    GetClientIpAddress(),
                    "DUO"
                );

                // Redirect to frontend with token
                return Redirect($"/auth-success?token={token}");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Duo callback error");
                return Redirect("/login?error=duo_failed");
            }
        }

        [HttpPost("mfa/verify-totp")]
        public async Task<IActionResult> VerifyTOTP([FromBody] MFAVerifyRequest request)
        {
            try
            {
                var isValid = VerifyTOTPCode(request.Secret, request.Code);
                
                if (isValid)
                {
                    // Save TOTP configuration
                    var authMethod = new UserAuthenticationMethod
                    {
                        UserId = request.UserId,
                        TenantId = request.TenantId,
                        AuthMethod = "MFA",
                        MFAProvider = "TOTP",
                        TotpSecret = request.Secret,
                        IsDefault = true,
                        CreatedDate = DateTime.UtcNow
                    };

                    _context.UserAuthenticationMethods.Add(authMethod);
                    await _context.SaveChangesAsync();

                    var token = GenerateJwtToken(request.TenantId, request.Email, request.Name);
                    
                    await _ssoService.LogSSOAttemptAsync(
                        request.TenantId,
                        request.Email,
                        "Success",
                        GetClientIpAddress(),
                        "TOTP"
                    );

                    return Ok(new { token, success = true });
                }

                return Unauthorized(new { message = "Invalid TOTP code" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "TOTP verification error");
                return StatusCode(500, new { message = "Verification failed" });
            }
        }

        private string GenerateTOTPSecret()
        {
            var key = KeyGeneration.GenerateRandomKey(20);
            return Base32Encoding.ToString(key);
        }

        private string GenerateQRCodeUrl(string email, string secret, string issuer)
        {
            return $"otpauth://totp/{Uri.EscapeDataString(issuer)}:{Uri.EscapeDataString(email)}?secret={secret}&issuer={Uri.EscapeDataString(issuer)}";
        }

        private string GenerateQRCodeImage(string qrCodeUrl)
        {
            using (var qrGenerator = new QRCodeGenerator())
            using (var qrCodeData = qrGenerator.CreateQrCode(qrCodeUrl, QRCodeGenerator.ECCLevel.Q))
            using (var qrCode = new PngByteQRCode(qrCodeData))
            {
                byte[] qrCodeBytes = qrCode.GetGraphic(20);
                return Convert.ToBase64String(qrCodeBytes);
            }
        }

        private bool VerifyTOTPCode(string secret, string code)
        {
            try
            {
                var secretBytes = Base32Encoding.ToBytes(secret);
                var totp = new Totp(secretBytes);
                return totp.VerifyTotp(code, out _, new VerificationWindow(2, 2));
            }
            catch
            {
                return false;
            }
        }

        private string GenerateJwtToken(string tenantId, string email, string name)
        {
            var securityKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));
            var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

            var claims = new[]
            {
                new Claim(ClaimTypes.Email, email),
                new Claim(ClaimTypes.Name, name),
                new Claim("tenantId", tenantId),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
            };

            var token = new JwtSecurityToken(
                issuer: _configuration["Jwt:Issuer"],
                audience: _configuration["Jwt:Audience"],
                claims: claims,
                expires: DateTime.Now.AddHours(8),
                signingCredentials: credentials
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }

        private string GetClientIpAddress()
        {
            return HttpContext.Connection.RemoteIpAddress?.ToString() ?? "Unknown";
        }
    }

    public class MFASetupRequest
    {
        public string Email { get; set; }
        public string TenantId { get; set; }
    }

    public class MFASetupResponse
    {
        public bool TotpAvailable { get; set; }
        public string TotpSecret { get; set; }
        public string TotpQrCodeUrl { get; set; }
        public string TotpQrCodeBase64 { get; set; }
        public bool DuoAvailable { get; set; }
        public string DuoEnrollmentMessage { get; set; }
    }

    public class DuoInitiateRequest
    {
        public string Username { get; set; }
        public string TenantId { get; set; }
    }

    public class MFAVerifyRequest
    {
        public int UserId { get; set; }
        public string TenantId { get; set; }
        public string Email { get; set; }
        public string Name { get; set; }
        public string Secret { get; set; }
        public string Code { get; set; }
    }
}

Step 7: Updated Program.cs for PostgreSQL

csharp
// Program.cs
using Microsoft.EntityFrameworkCore;
using Npgsql;
using YourApp.Data;
using YourApp.Services;

var builder = WebApplication.CreateBuilder(args);

// Configure PostgreSQL
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions => npgsqlOptions.EnableRetryOnFailure(
            maxRetryCount: 5,
            maxRetryDelay: TimeSpan.FromSeconds(30),
            errorCodesToAdd: null)));

// Add services
builder.Services.AddMemoryCache();
builder.Services.AddHttpContextAccessor();
builder.Services.AddScoped<ITenantSSOService, TenantSSOService>();
builder.Services.AddScoped<IDuoService, DuoService>();

// Configure JWT Authentication
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
        };
    });

builder.Services.AddAuthorization();
builder.Services.AddControllers();
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAngularApp", policy =>
    {
        policy.WithOrigins("http://localhost:4200", "https://your-domain.com")
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});

var app = builder.Build();

app.UseCors("AllowAngularApp");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();

Frontend Implementation (Angular 18) - Updated for Duo
Step 8: Updated Auth Service with Duo Support

typescript
// src/app/services/auth.service.ts (Updated)
import { Injectable, inject, signal } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { map, switchMap, catchError, tap } from 'rxjs/operators';

export interface MFASetupResponse {
  totpAvailable: boolean;
  totpSecret?: string;
  totpQrCodeUrl?: string;
  totpQrCodeBase64?: string;
  duoAvailable: boolean;
  duoEnrollmentMessage?: string;
}

export interface DuoInitiateResponse {
  authUrl: string;
  message: string;
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private http = inject(HttpClient);
  private apiUrl = 'https://your-api-url.com/api';
  
  setupMFA(email: string, tenantId: string): Observable<MFASetupResponse> {
    return this.http.post<MFASetupResponse>(
      `${this.apiUrl}/auth/mfa/setup`,
      { email, tenantId }
    );
  }

  initiateDuoAuth(username: string, tenantId: string): Observable<DuoInitiateResponse> {
    return this.http.post<DuoInitiateResponse>(
      `${this.apiUrl}/auth/mfa/initiate-duo`,
      { username, tenantId }
    );
  }

  verifyTOTP(userId: number, code: string, secret: string, email: string, name: string, tenantId: string): Observable<boolean> {
    return this.http.post<{ token: string; success: boolean }>(
      `${this.apiUrl}/auth/mfa/verify-totp`,
      { userId, code, secret, email, name, tenantId }
    ).pipe(
      map(response => {
        if (response.success) {
          this.setSession(response.token, { email, name, tenantId });
        }
        return response.success;
      }),
      catchError(() => of(false))
    );
  }

  // ... (rest of the auth service methods)
}

Step 9: Updated Login Component with Duo

typescript
// src/app/components/login/login.component.ts (Updated)
import { Component, OnInit, signal, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { AuthService, TenantConfig, MFASetupResponse } from '../../services/auth.service';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.css']
})
export class LoginComponent implements OnInit {
  private fb = inject(FormBuilder);
  private authService = inject(AuthService);
  private router = inject(Router);
  private route = inject(ActivatedRoute);

  loginForm: FormGroup;
  tenantConfig = signal<TenantConfig | null>(null);
  mfaSetupData = signal<MFASetupResponse | null>(null);
  showMFAChoice = signal<boolean>(false);
  showTOTPSetup = signal<boolean>(false);
  showTOTPVerify = signal<boolean>(false);
  selectedMFAProvider = signal<string>('');
  loading = signal<boolean>(false);
  error = signal<string | null>(null);

  ngOnInit(): void {
    this.loginForm = this.fb.group({
      tenantId: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      password: [''],
      totpCode: ['']
    });

    // Check for auth success from Duo callback
    this.route.queryParams.subscribe(params => {
      if (params['token']) {
        // Handle token from Duo callback
        const user = { email: params['email'], name: params['name'], tenantId: params['tenantId'] };
        this.authService['setSession'](params['token'], user);
        this.router.navigate(['/dashboard']);
      }
      if (params['error']) {
        this.error.set(params['error']);
      }
    });
  }

  setupMFA(): void {
    const { email, tenantId } = this.loginForm.value;
    
    this.loading.set(true);
    this.authService.setupMFA(email, tenantId).subscribe({
      next: (response) => {
        this.mfaSetupData.set(response);
        
        if (response.totpAvailable && response.duoAvailable) {
          this.showMFAChoice.set(true);
        } else if (response.totpAvailable) {
          this.showTOTPSetup.set(true);
        } else if (response.duoAvailable) {
          this.initiateDuoAuth();
        }
        
        this.loading.set(false);
      },
      error: () => {
        this.error.set('MFA setup failed');
        this.loading.set(false);
      }
    });
  }

  selectMFAProvider(provider: string): void {
    this.selectedMFAProvider.set(provider);
    this.showMFAChoice.set(false);
    
    if (provider === 'TOTP') {
      this.showTOTPSetup.set(true);
    } else if (provider === 'DUO') {
      this.initiateDuoAuth();
    }
  }

  initiateDuoAuth(): void {
    const { email, tenantId } = this.loginForm.value;
    
    this.loading.set(true);
    this.authService.initiateDuoAuth(email, tenantId).subscribe({
      next: (response) => {
        // Redirect to Duo authentication page
        window.location.href = response.authUrl;
      },
      error: () => {
        this.error.set('Failed to initiate Duo authentication');
        this.loading.set(false);
      }
    });
  }

  proceedToTOTPVerification(): void {
    this.showTOTPSetup.set(false);
    this.showTOTPVerify.set(true);
  }

  verifyTOTP(): void {
    const { email, tenantId, totpCode } = this.loginForm.value;
    const mfaData = this.mfaSetupData();
    const userId = 1; // Get from login response

    this.authService.verifyTOTP(userId, totpCode, mfaData?.totpSecret || '', email, email, tenantId).subscribe({
      next: (success) => {
        if (success) {
          this.router.navigate(['/dashboard']);
        } else {
          this.error.set('Invalid TOTP code');
        }
      }
    });
  }
}

xml
<!-- src/app/components/login/login.component.html (Updated) -->
<div class="login-container">
  <div class="login-card">
    <h2>Login</h2>
    
    @if (error()) {
      <div class="alert alert-danger">{{ error() }}</div>
    }

    <!-- MFA Provider Choice -->
    @if (showMFAChoice()) {
      <div class="mfa-choice">
        <h3>Choose Your MFA Method</h3>
        <div class="mfa-options">
          @if (mfaSetupData()?.totpAvailable) {
            <button 
              type="button"
              (click)="selectMFAProvider('TOTP')"
              class="btn btn-outline-primary btn-block"
            >
              <i class="icon-authenticator"></i>
              Authenticator App (TOTP)
            </button>
          }
          
          @if (mfaSetupData()?.duoAvailable) {
            <button 
              type="button"
              (click)="selectMFAProvider('DUO')"
              class="btn btn-outline-primary btn-block"
            >
              <i class="icon-duo"></i>
              Duo Security
            </button>
          }
        </div>
      </div>
    }

    <!-- TOTP Setup -->
    @if (showTOTPSetup()) {
      <div class="totp-setup">
        <h3>Setup Authenticator App</h3>
        <p>Scan this QR code with your authenticator app:</p>
        
        @if (mfaSetupData()?.totpQrCodeBase64) {
          <img 
            [src]="'data:image/png;base64,' + mfaSetupData()?.totpQrCodeBase64" 
            alt="TOTP QR Code"
            class="qr-code"
          />
        }
        
        <p class="secret-key">
          <strong>Manual Entry Key:</strong><br>
          <code>{{ mfaSetupData()?.totpSecret }}</code>
        </p>
        
        <button 
          type="button"
          (click)="proceedToTOTPVerification()"
          class="btn btn-primary btn-block"
        >
          Continue to Verification
        </button>
      </div>
    }

    <!-- TOTP Verification -->
    @if (showTOTPVerify()) {
      <div class="totp-verify">
        <h3>Enter Verification Code</h3>
        <form [formGroup]="loginForm">
          <div class="form-group">
            <label for="totpCode">6-Digit Code</label>
            <input 
              type="text"
              id="totpCode"
              formControlName="totpCode"
              class="form-control code-input"
              placeholder="000000"
              maxlength="6"
              pattern="[0-9]*"
            />
          </div>
          <button 
            type="button"
            (click)="verifyTOTP()"
            [disabled]="loading() || !loginForm.get('totpCode')?.value"
            class="btn btn-primary btn-block"
          >
            Verify
          </button>
        </form>
      </div>
    }
  </div>
</div>

Configuration Files
PostgreSQL Connection String

json
// appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=your_database;Username=your_user;Password=your_password;SSL Mode=Require;"
  },
  "Jwt": {
    "Key": "your-super-secret-key-minimum-32-characters-long",
    "Issuer": "https://your-api-url.com",
    "Audience": "https://your-angular-app.com"
  },
  "Encryption": {
    "Key": "your-encryption-key-32-characters-long"
  }
}